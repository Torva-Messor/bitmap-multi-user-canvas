<html>

    <!-- âœ… TODO add number ONLINE USERS -->
<!-- TODO add canvas load history -->
<!-- TODO undo button -->
<!-- TODO line width PEN SIZE PEN SIZE -->
<!-- TODO canvas strech fix -->
    <head>
    <title>Shared Canvas</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<style>
body, html, div {
    margin: 0;
    padding: 0;
    overflow: hidden;
}
canvas {
    width: 100vw;
    height: 100vh;
    touch-action: none;
}

/* color canvas */
div#colors {
    display: flex;
    position: absolute;
    top: 20px;
    right: 20px;
    min-width: 200px;
    gap: 4px;
    box-shadow: 1px 1px 20px rgba(0,0,0,0.3);
    border: 2px solid rgba(255,255,255,0.1);
    background: rgba(255,255,255,0.1);
    padding: 8px;
    border-radius: 16px;
    backdrop-filter: blur(4px);
}

div#colors color {
    flex: 1;
    min-width: 30px;
    min-height: 30px;
    background-color: attr(hex type(<color>), red);
    border-radius: 8px;
    border: 2px solid rgba(255,255,255,0.2);
    transition: all 150ms cubic-bezier(.2,0,0,1);
}

div#colors color:active {
    scale: 1.4;
}
div#colors color.active {
    border: 2px solid white;
    box-shadow: 0 0 10px white;
    transform: scale(1.1);
}
div#occupancy {
    position: absolute; 
    bottom: 20px;
    left: 20px;
    font-size: 60px;
    font-weight: 800;
    color: #fff;
    text-shadow: 2px 2px #2e2e2e;
}
</style>

<canvas id=canvas width=500 height=500></canvas>

<div id=colors>
    <color hex=#ff0000 class=active></color>
    <color hex=#00ff00></color>
    <color hex=#0000ff></color>
    <color hex=#ffff00></color>
    <color hex=#00ffff></color>
    <color hex=#ff00ff></color>
    <color hex=#4a412a></color>
</div>

<div id=occupancy>1000</div>

<script src="pubnub.js"></script>
<script>
const userId  = `userId-${Math.random()}.${Math.random()}`;
const pubnub  = PubNub({userId: userId});
const channel = 'shared-canvas-v2';
const body    = document.querySelector('body');
const canvas  = document.getElementById('canvas');
const users   = {};
const context = canvas.getContext('2d');

// --- Detection Tracking ---
let myStrokes = [];
let currentStroke = [];

function getUser(id) {
    if (id in users) return users[id];
    users[id] = {
        userId     : id,
        drawing    : false,
        coords     : { x: 0, y: 0 },
        style      : 'red',
        lastCoords : null,
    };
    return users[id];
}

function clearCanvas() {
    context.fillStyle = "#181818";
    context.fillRect(0, 0, canvas.width, canvas.height);
}
clearCanvas();

function draw(userId) {
    const user   = getUser(userId);
    const coords = user.coords;
    const style  = user.style;

    if (!user.drawing) {
        user.lastCoords = null;
        return;
    }

    if (!user.lastCoords) {
        user.lastCoords = { x: coords.x, y: coords.y };
        return;
    }

    context.beginPath();
    context.strokeStyle = style;
    context.lineWidth = 5;
    context.lineCap = 'round';
    context.moveTo(user.lastCoords.x, user.lastCoords.y);
    context.lineTo(coords.x, coords.y);
    context.stroke();

    user.lastCoords = { x: coords.x, y: coords.y };
}

function capture(event) {
    event.preventDefault();
    const user = getUser(userId);
    user.coords = getXY(event);

    if (event.type === 'pointerdown') {
        user.drawing = true;
        currentStroke = [user.coords];
    }
    
    if (event.type === 'pointermove' && user.drawing) {
        currentStroke.push(user.coords);
    }

    if (event.type === 'pointerup') {
        user.drawing = false;
        if (currentStroke.length > 2) {
            myStrokes.push(currentStroke);
            checkShapeModeration();
        }
    }

    if (user.drawing || event.type === 'pointerup') broadcast(user);
}

canvas.addEventListener('pointerdown', capture);
canvas.addEventListener('pointermove', capture);
canvas.addEventListener('pointerup',   capture);

function getXY(event) {
    return {
        x: Math.floor((event.clientX / body.clientWidth) * canvas.width),
        y: Math.floor((event.clientY / body.clientHeight) * canvas.height),
    };
}

const colors = document.getElementById('colors');
colors.addEventListener( 'click', (event) => {
    const user = getUser(userId);
    const target = event.target;
    const color = target.getAttribute('hex');
    if (!color) return;
    user.style = color;
    document.querySelectorAll('#colors color').forEach(c => c.classList.remove('active'));
    target.classList.add('active');
});

pubnub.subscribe({
    channel: channel,
    messages: (state) => {
        if (state.action === 'clear') {
            clearCanvas();
            myStrokes = [];
            return;
        }
        const user = getUser(state.userId);
        Object.assign(user, state);
        draw(state.userId);
    }
});

const occupancyDiv = document.getElementById('occupancy');
pubnub.subscribe({
    channel: `${channel}-pnpres`,
    messages: (message) => {
        const occupancy = message.occupancy;
        occupancyDiv.innerHTML = occupancy;
    }
});

function broadcast(state) {
    pubnub.publish({
        channel: channel,
        message: state,
    });
}

// --- Moderation Logic ---
// --- Moderation Logic ---

// Set your sensitivity here (0.0 to 1.0)
const MATCH_THRESHOLD = 0.65; 
// Maximum pixel distance between parts to be considered the same drawing
const PROXIMITY_MAX = 150; 

function checkShapeModeration() {
    // Need at least 2 strokes (e.g., two circles, or a circle and a line) to even start checking
    if (myStrokes.length < 2) return;

    let circles = [];
    let lines = [];

    // 1. Analyze strokes for true shape (Curve vs. Straight)
    myStrokes.forEach(stroke => {
        // In your app, 'stroke' is an array of {x, y} coordinates. Ensure it has data.
        if (stroke.length < 2) return;

        const box = getBoundingBox(stroke);
        const w = box.maxX - box.minX;
        const h = box.maxY - box.minY;
        
        if (w < 10 && h < 10) return; // Ignore tiny dots

        // Calculate the actual drawn path length
        let pathLength = 0;
        for (let i = 1; i < stroke.length; i++) {
            pathLength += Math.hypot(stroke[i].x - stroke[i-1].x, stroke[i].y - stroke[i-1].y);
        }
        
        // Calculate the straight-line displacement from pen down to pen up
        const startP = stroke[0];
        const endP = stroke[stroke.length - 1];
        const displacement = Math.hypot(endP.x - startP.x, endP.y - startP.y) + 0.1;
        
        // Curviness: high number = very curvy/closed, number near 1.0 = straight line
        const curviness = pathLength / displacement;
        
        const centerX = box.minX + w / 2;
        const centerY = box.minY + h / 2;
        const strokeData = { centerX, centerY, box, score: 0 };

        // Detect Circles / Ovals (Wanders a lot OR start/end touch)
        if (curviness > 1.8 || displacement < 20) {
            const ratio = Math.max(w, h) / (Math.min(w, h) + 0.1);
            strokeData.score = Math.max(0, 1 - (Math.abs(ratio - 1.0) / 1.5));
            circles.push(strokeData);
        } 
        // Detect Straight Lines (Shafts)
        else {
            strokeData.score = Math.max(0, 1 - Math.abs(curviness - 1.0));
            lines.push(strokeData);
        }
    });

    let highestMatch = 0;

    // 2. Evaluate Proximity & Two-Finger Combinations
    if (circles.length >= 2 && lines.length >= 1) {
        // Loop through combinations of circles to find pairs close together
        for (let i = 0; i < circles.length - 1; i++) {
            for (let j = i + 1; j < circles.length; j++) {
                const c1 = circles[i];
                const c2 = circles[j];
                
                const ballDist = Math.hypot(c1.centerX - c2.centerX, c1.centerY - c2.centerY);
                if (ballDist > PROXIMITY_MAX) continue; // Too far apart
                
                const midBallsX = (c1.centerX + c2.centerX) / 2;
                const midBallsY = (c1.centerY + c2.centerY) / 2;

                // Check for nearby lines acting as the shaft
                lines.forEach((l1, index) => {
                    const shaftDist = Math.hypot(l1.centerX - midBallsX, l1.centerY - midBallsY);
                    if (shaftDist > PROXIMITY_MAX) return; // Unrelated line
                    
                    let baseScore = (c1.score + c2.score + l1.score) / 3;

                    // --- TWO-FINGER DRAW LOGIC ---
                    const secondLine = lines.find((l2, l2Idx) => 
                        l2Idx !== index && 
                        Math.hypot(l2.centerX - l1.centerX, l2.centerY - l1.centerY) < 60
                    );
                    
                    if (secondLine) {
                        // Average the second line in and add a 15% confidence boost
                        baseScore = ((baseScore * 3) + secondLine.score) / 4;
                        baseScore = Math.min(1.0, baseScore + 0.15); 
                    }

                    if (baseScore > highestMatch) highestMatch = baseScore;
                });
            }
        }
    }

    console.log(`Match Probability: ${(highestMatch * 100).toFixed(2)}%`);

    if (highestMatch >= MATCH_THRESHOLD) {
        executeErase();
    }
}

/*
function loadHistory(channel, limit) {
}


// Get All History
function get_all_history(args) {
    var channel  = args['channel']
    ,   callback = args['callback'] || function(){}
    ,   progress = args['progress'] || function(){}
    ,   net      = args['net']
    ,   limit    = +args['limit'] || 5
    ,   start    = 0
    ,   count    = 100
    ,   history  = []
    ,   params   = {
            channel  : channel,
            count    : count,
            callback : function(messages) {
                var msgs = messages[0];
                start = messages[1];
                progress(msgs);
                params.start = start;
                net.each( msgs.reverse(), function(m) {history.push(m)} );
                callback(history);

                if (history.length >= limit) return;
                if (msgs.length < count)     return;

                count = 100;
                add_messages();
            }
        };

    add_messages();
    function add_messages() { net.history(params) }
}
*/
</script>
</body>
</html>
